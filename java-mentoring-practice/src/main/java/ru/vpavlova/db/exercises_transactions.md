## Аномалии при работе с транзакциями
### Грязное чтение
Грязное чтение - это ситуация, когда одна транзакция читает данные, которые были изменены другой, еще не завершенной транзакцией (и которая может быть откачена).
В Postgres воспроизвести не получится т.к уровень изоляции по-умолчанию - READ_COMMITED
### Потерянное обновление
Lost Update - это ситуация, когда изменения одной транзакции перезаписываются изменениями другой транзакции, потому что они работают с одними и теми же данными без должной синхронизации.

**Решить задачу на следующем примере:**

- Есть банковский счет клиента:

`create table accounts (id int primary key, name text, balance int);`

`insert into accounts values (1, 'Ve', 1000);`

- Транзакция T1 читает данные:

`BEGIN;`

`SELECT balance FROM accounts WHERE id = 1;`

- Транзакция T2 читает данные:

`BEGIN;`

`SELECT balance FROM accounts WHERE id = 1;`

- Транзакция T1 осуществляет списание за покупку - 200р.:

`UPDATE accounts SET balance = 800 WHERE id = 1; -- 1000 - 200`

- Транзакция T2 осуществляет списание за покупку - 300р.:

`UPDATE accounts SET balance = 700 WHERE id = 1; -- 1000 - 300`

- Транзакция T1 коммитит изменения:

`COMMIT;`

- Транзакция T2 коммитит изменения:

`COMMIT;`

Задача должна быть решена следующими способами:

- пессимистичной блокировкой на запись -- SELECT FOR UPDATE
- повышением уровня изоляции
- обновлением с помощью атомарной операции

### Неповторяющееся чтение

Неповторяющееся чтение возникает, когда транзакция повторно читает те же данные и обнаруживает, что они были изменены другой транзакцией, которая была зафиксирована между этими чтениями.


**Решить задачу на следующем примере:**

- Есть банковский счет клиента:

`create table accounts (id int primary key, name text, balance int);`

`insert into accounts values (1, 'Ve', 1000);`

- Транзакция T1 читает данные:

`BEGIN;`

`SELECT balance FROM accounts WHERE id = 1; -- Читает 1000`

- Транзакция T2 изменяет данные:

`BEGIN;`

`UPDATE accounts SET balance = 800 WHERE id = 1;`

`COMMIT;`

- Транзакция T1 снова читает данные:

`SELECT balance FROM accounts WHERE id = 1; -- Читает 800`

**Проблема**: В рамках одной транзакции T1 два одинаковых запроса вернули разные результаты (1000 и 800), потому что между чтениями другая транзакция T2 изменила и зафиксировала данные.

Задача должна быть решена следующими способами:

- блокировка на чтение -- SELECT FOR SHARE
- повышением уровня изоляции

### Фантомное чтение

Фантомное чтение — это ситуация, когда в пределах одной транзакции повторное выполнение одного и того же запроса возвращает разные наборы строк из-за того, что другая транзакция успела добавить или удалить данные.

- Есть банковские счета клиентов:

`create table accounts (id int primary key, name text, balance int);`

`insert into accounts values (1, 'Ve', 1000);`

`insert into accounts values (2, 'Be', 2000);`

`insert into accounts values (3, 'Me', 3000);`

- Транзакция T1 читает данные клиентов с балансом > 1000:

`BEGIN;`

`SELECT balance FROM accounts WHERE balance > 1000;`


- Транзакция T2 добавляет нового клиента с балансом 5000:

`BEGIN;`

`insert into accounts values (4, 'Star', 5000);`

`COMMIT;`

- Транзакция T1 СНОВА читает данные клиентов с балансом > 1000:

`SELECT balance FROM accounts WHERE balance > 1000;`

**Проблема**: Транзакция T1 получила разные данные при повторном запросе. Если T1 принимала решение на основе первого результата, оно может быть некорректным.

Задача должна быть решена следующими способами:

- блокировка диапазона на чтение -- SELECT FOR UPDATE
- повышением уровня изоляции

